# 1.Introduction

因为多核架构的创新设计，计算机行业正在经历一场翻天覆地的变化。 至少目前，主要的芯片制造商已放弃尝试使处理器运行得更快。 摩尔定律尚未废除：每年，越来越多的晶体管适用于相同的空间，但是如果没有过热，它们的时钟速度就无法提高。 相反，制造商正在转向“多核”架构，其中多个处理器（核心）通过共享硬件缓存直接通信。多处理器芯片通过利用并行性使计算更有效：利用多个处理器来处理单个任务。

多处理器架构的普及将对我们开发软件的方式产生普遍影响。 直到最近，技术的进步意味着时钟速度的提高，因此软件会随着时间的推移自动“加速”。 然而，现在这个免费搭车已经结束了。 技术的进步将意味着增加并行性而不是提高时钟速度，并且利用这种并行性是现代计算机科学的突出挑战之一。

本书重点介绍如何基于共享内存进行通信的多处理器进行编程。 此类系统通常称为共享内存多处理器，最近又简称为多核(multicores)。 编程挑战出现在多处理器系统的各种规模上 - 在非常小的规模上，单个芯片内的处理器需要协调对共享存储器位置的访问，而在大规模上，超级计算机中的处理器需要协调数据的路由。 多处理器编程具有挑战性，因为现代计算机系统本质上是异步的：可以在没有中断，抢占，高速缓存未命中，故障和其他事件警告的情况下停止或延迟活动。 这些延迟本质上是不可预测的，并且可能在规模上有很大差异：高速缓存未命中可能使处理器延迟少于10个指令，几百万个指令的页面错误，或者数亿个指令的操作系统抢占。

我们从两个互补的方向探讨多处理器编程：原理和实践。 在本书的原理部分，我们关注可计算性：确定可以在异步并发环境中计算的内容。 我们使用理想化的计算模型，其中多个并发线程操纵一组共享对象。 对象上的线程操作序列称为并发程序(concurrent program)或并发(concurrent algorithm)算法。 该模型本质上是Java，C＃或C ++线程包提供的模型。

令人惊讶的是，有一些易于指定的共享对象无法通过任何并发算法实现。 因此，在继续编写多处理器程序之前，了解不要尝试的内容非常重要。 使多处理器程序员陷入困境的许多问题都是计算模型基本限制的结果，因此我们认为获得对并发共享内存可计算性的基本理解是必要的步骤。 处理原则的章节让读者快速浏览异步可计算性，尝试揭示各种可计算性问题，以及如何通过使用硬件和软件机制解决这些问题。

理解可计算性的一个重要步骤是规范和验证给定程序实际执行的操作。这可能最好描述为程序正确性。多处理器程序本身的正确性比它们的顺序对应程序更复杂，并且需要一套不同的工具，即使是为了“非正式推理”（当然，这是大多数程序员实际做的事情） ）。顺序正确性主要与安全性有关。安全性表明某些“坏事”永远不会发生。例如，即使电源出现故障，红绿灯也不会在所有方向上显示绿色。当然，并发正确性也与安全性有关，但问题要困难得多，因为尽管可以交错并发线程的步骤的方式很多，但必须确保安全性。同样重要的是，并发正确性包含在顺序世界中没有对应物的各种活跃属性。活跃的安全性声明会发生一件特别好的事情。例如，红色交通灯最终会变为绿色。本书涉及原则的部分的最终目标是引入各种计量和方法来推理并发程序，这些程序稍后将在讨论现实世界对象和程序的正确性时为我们服务。

本书的第二部分涉及多处理器编程的实践，并侧重于性能。 分析多处理器算法的性能与分析顺序程序的性能方面也有所不同。 顺序编程基于一系列成熟且易于理解的抽象。 当我们编写顺序程序时，我们通常不需要知道在它下面的所有页面都是从磁盘交换到内存，而较小的内存单元正在进出处理器缓存的层次结构。 这种复杂的内存层次结构基本上是不可见的，隐藏在简单的编程抽象背后。

在多处理器上下文中，这种抽象分解，至少从性能角度来看。 为了获得足够的性能，程序员有时必须“知晓”底层内存系统，编写对于不熟悉多处理器体系结构的人来说看起来很奇怪的程序。有时候，并发体系结构将提供现在由顺序体系结构提供的相同程度的高效抽象，但是 与此同时，程序员应该小心。

本书的原理部分陆续介绍了共享对象和编程工具的集合。 每个对象和工具本身都很有趣，我们通过各个对象和工具向读者展示更高级别的问题：自旋锁说明了争用，链表说明了锁定在数据结构设计中的作用，等等。 这些问题中的每一个都对程序性能产生重要影响。 希望读者将所学到的知识应用于特定多处理器系统的编程实践中。 我们最后将讨论最先进的技术（如事务存储器）。

我们想简单介绍一下风格。 本书使用Java编程语言。 当然，还有其他合适的语言，读者会发现它们同样具有吸引力。 我们有一长串原因供我们选择，但也许更适合在茶话会上讨论选择哪种语言！ 在附录中，我们解释了如何用其他流行语言或库表达Java中表达的概念。 我们还提供了多处理器硬件的入门知识。 在整本书中，我们避免为程序和算法提供特定的性能参数，并坚持一般趋势。 这有一个很好的理由：多处理器差别很大，不幸的是，在这个时间点，在一台机器上运行良好的程序在另一台机器上可能会显着不那么令人满意。 坚持一般趋势是我们保证我们的结果在长时间内正确的一种方式。

我们提供每章末尾的参考资料。 读者将找到所涵盖材料的书目调查，并提供进一步阅读的建议。 每一章还包括一系列练习，读者可以用这些练习来衡量他们在星期天早上的理解或自我检测。

## 1.1 Shared Objects and Synchronization

在你的新工作的第一天，你的老板要求你找到1到10的10次方(10^10)之间的所有素数（不要关心为什么），使用支持10个并发线程的并行机器。 这台机器按分钟租用，因此程序花费的时间越长，成本就越高。 你想给人留下好印象。 你该怎么办？

作为第一次尝试，您可以考虑为每个线程分配相同的输入域份额。 每个线程可能会检查10的9次方个数字，如图1.1所示。 出于基本但重要的原因，这种方法失败了。 相同范围的投入不一定产生相同数量的工作。 素数不均匀地发生：1到10^9之间有许多素数，但在9乘以10的9次方(9*10^9)到10的10次方(10^10)之间几乎没有。更糟糕的是，每个素数的计算时间在所有范围内都不相同：通常需要更长的时间来测试是否大数是素数而不是小数。 简而言之，没有理由相信工作将在线程之间平均分配，并且即使哪些线程最有效也不清楚。

```java
void primePrint {
    int i = ThreadID.get(); // thread IDs are in {0..9}
    int block = power(10, 9);
    for (int j = (i * block) + 1; j <= (i + 1) block; j++) {
        if (isPrime(j)) 
            print(j);
    }
}
``` 
```

![Figure 1.1 Balancing load by dividing up the input domain. Each thread in {0..9} gets an equal subset of the range. ](https://github.com/mysonhushu/the-art-of-multiprocessor-programming-zh/blob/master/manuscript/images/Figure1-1.png "Figure 1.1 Balancing load by dividing up the input domain. Each thread in {0..9} gets an equal subset of the range.")


在线程之间拆分工作的更有前途的方法是一次为每个线程分配一个整数（图1.2）。 当一个线程完成测试整数时，它会要求另一个。 为此，我们引入了一个共享计数器，一个封装整数值的对象，它提供了一个递增其值的 getAndIncrement() 方法，并将计数器的先前值返回给调用者。

```java
Counter counter = new Counter(1); // shared by all threads
void primePrint {
    long i = 0;
    long limit = power(10, 10);
    while (i < limit) {           // loop until all numbers taken
        i = counter.getAndIncrement();  // take next untaken number
        if (isPrime(i))
             print(i);

    }
}
```



![Figure 1.2 Balancing the work load using a shared counter. Each thread gets a dynamically determined number of numbers to test. ](https://github.com/mysonhushu/the-art-of-multiprocessor-programming-zh/blob/master/manuscript/images/Figure1-2.png "Figure 1.2 Balancing the work load using a shared counter. Each thread gets a dynamically determined number of numbers to test.")


图1.3显示了Java中的Counter的自然实现。 这个计数器实现在单个线程使用时运行良好，但在多个线程共享时失败。 问题在于表达方式:

```java
return value++;
```

实际上是以下更复杂代码的缩写：

```java
long temp = value;
value = temp + 1;
return temp;
```

在此代码片段中，value是Counter对象的成员变量，并在所有线程之间共享。 但是，每个线程都有自己的temp本地副本，它是每个线程的局部变量。

```java
public class Counter {
    private long value; // counter starts at one
    public Counter(int i) { // constructor initializes counter
        value = i;
    }

    public long getAndIncrement() { // increment, returning prior value
        return value++;
    }
}
```


![Figure 1.3 An implementation of the shared counter](https://github.com/mysonhushu/the-art-of-multiprocessor-programming-zh/blob/master/manuscript/images/Figure1-3.png "Figure 1.3 An implementation of the shared counter")


现在假设线程 A 和 B 几乎同时调用计数器的 getAndIncrement() 方法。 它们可能同时从 value 读取1，将其本地临时变量设置为1，将 value 设置为2，并且都返回1.此行为不是我们想要的：对计数器的 getAndIncrement() 的并发调用返回相同的值，但我们期望它们返回不同的值。 事实上，它可能会变得更糟。 一个线程可能从 value 读取1，但在将 value 设置为2之前，另一个线程将多次通过增量循环，读取 1 并设置为 2，读取 2 并设置为 3.当第一个线程最终完成其操作时, 将 value 设置为2，它实际上将计数器从 3 设置为 2。

问题的核心是递增计数器的值需要对共享变量进行两个不同的操作：将值字段读入临时变量并将其写回Counter对象。

当你试图让一个人在走廊里正面接近你时会发生类似的事情。 您可能会发现自己正确转向，然后离开几次以避免其他人做同样的事情。 有时你会设法避免撞到它们，有时你却不会碰到它们，事实上，正如我们在后面的章节中看到的那样，这种冲突现象是不可避免的。 在一个直观的层面上，正在发生的事情是你们每个人都在执行两个不同的步骤：查看（“阅读”）对方的当前位置，以及移动（“书写”）到一侧或另一侧。 问题是，当你读到对方的位置时，你无法知道他们是否决定原地不动还是移动到另一侧。 就像你和烦人的陌生人必须决定谁走左边,谁走右边一样，访问共享计数器的线程必须决定谁先执行，谁后执行。

正如我们将在第5章中看到的那样，现代多处理器硬件提供了特殊的读 - 修改 - 写指令(read-modify-write instructions)，允许线程在一个原子（即不可分割的）硬件步骤中读取，修改和写入存储器的值。 对于 Counter 对象，我们可以使用这样的硬件以原子方式递增计数器

我们还可以通过在软件中保证（仅使用读和写指令）来提供这样的原子行为，即一次只有一个线程执行读写序列。 确保一次只有一个线程可以执行特定代码块的问题称为互斥问题，并且是多处理器编程中的经典协调问题之一。

实际上，您不太可能发现自己必须设计自己的互斥算法（相反，您可能会调用库）。 然而，理解如何从基础中实现互斥是一般理解并发计算的必要条件。 没有更有效的方法来学习如何推理基本和无处不在的问题，例如互斥，死锁，有限公平，阻塞与非阻塞同步。

## 1.2 A Fable

我们不将协调问题（例如互斥）视为编程练习，而是将并发协调问题视为物理问题。 现在我们通过一系列寓言，说明一些基本问题。 像大多数寓言作者一样，我们重述了其他人发明的故事（参见本章末尾的章节注释）。

爱丽丝和鲍勃是邻居，他们共用一个院子。 爱丽丝拥有一只猫，鲍勃拥有一只狗。 两只宠物都喜欢在院子里跑来跑去，但（自然地）他们不相处。 在一些不幸的经历之后，爱丽丝和鲍勃同意他们应该协调以确保两只宠物永远不会同时在院子里。 当然，我们排除了不允许任何动物进入空院子的暴力解决方案。

他们应该怎么做？ 爱丽丝和鲍勃需要就相互兼容的程序达成一致，以决定做什么。 我们称这样的协议为协调协议（或简称协议）。

院子很大，所以爱丽丝不能简单地向窗外看，看看鲍勃的狗是否在场。 她也许可以走到鲍勃的家里敲门，但这需要很长时间，如果下雨会怎么样？ 爱丽丝可能会向窗外倾斜并大喊“嘿鲍勃！ 我可以让猫出去吗？“问题是鲍勃可能听不到她的声音。 他可能正在看电视，拜访他的女朋友，或外出购买狗粮。 他们可以尝试通过手机进行协调，但如果鲍勃正在洗澡，开车穿过隧道或给手机电池充电，也会遇到同样的困难。

爱丽丝有一个聪明的主意。 她在鲍勃的窗台上放了一个或多个空啤酒罐（图1.4），在每个窗台上绑一根绳子，然后把绳子放回她家。 鲍勃也这样做。 当她想向鲍勃发送信号时，她猛拉绳子敲击其中一个罐头。 当鲍勃注意到一个罐子被撞倒时，他重置了罐头。


![Figure 1.4 Communicating with cans](https://github.com/mysonhushu/the-art-of-multiprocessor-programming-zh/blob/master/manuscript/images/Figure1-4.png "Figure 1.4 Communicating with cans")


它仍然存在严重缺陷。 问题是，爱丽丝只能在鲍勃的窗台上放置有限数量的罐头，迟早，她将用尽罐头来敲门。 当然，鲍勃在注意到它被击倒后立即重置了一个罐子，但是如果他去春游了呢？ 只要爱丽丝依赖鲍勃来重置啤酒罐，她迟早会跑出去。

所以爱丽丝和鲍勃尝试了不同的方法。 每一个都设置一个旗杆，容易看到另一个。 当爱丽丝想要释放她的猫时，她会做以下事情：

1. 她升起她的旗帜。
2. 当鲍勃的旗帜降下来时，她释放了她的猫。
3. 当她的猫回来时，她降下她的旗帜。

鲍勃的行为有点复杂。

1. 他升起他的旗帜。
2. 当爱丽丝的起至也升起的时候。
   - 鲍勃降下自己的旗帜。
   - 鲍勃原地等待，直到爱丽丝的旗帜降下来。
　 - 鲍勃保持他的旗帜一直升起。
3. 一旦他的旗帜升起并且她的旗帜下降，他就会释放他的狗。
4.  当他的狗回来时，他降下他的旗帜。

该协议奖励进一步研究作为爱丽丝和鲍勃问题的解决方案。 在直观的层面上，它的工作原理是以下标志原则。 如果爱丽丝和鲍勃各自

1. 升起他们自己的旗帜之后，马上
2. 看看对方的旗帜是否升起

然后至少有一个会看到对方的旗帜升起（显然，最后一个看起来会看到对方的旗帜升起）并且不会让他或她的宠物进入院子。 然而，这种观察并不能证明宠物永远不会在院子里。 例如，如果爱丽丝在鲍勃看的时候让她的猫进出院子几次怎么办？

为了证明宠物永远不会在院子里一起，通过矛盾的方式假设宠物可以一起最终进入院子里。 考虑上一次爱丽丝和鲍勃各自举起旗帜，看着对方的旗帜，然后将宠物送到院子里。 当爱丽丝最后看时，她的旗帜已经完全抬起。 她一定没看过鲍勃的旗帜，或者她不会释放猫，所以鲍勃在爱丽丝开始寻找之前一定还没有完成他的旗帜。 因此，当鲍勃最后一次看到，在举起旗帜之后，一定是在爱丽丝开始寻找之后，所以他一定看到爱丽丝的旗帜升起并且不会释放他的狗，这是一个矛盾。

这种矛盾的论证一再出现，值得花一些时间说服自己为什么这种说法是正确的。 值得注意的是，我们从未假设“升起我的旗帜”或“看着你的旗帜”瞬间发生，我们也没有假设这些活动需要多长时间。 我们关心的是这些活动何时开始或结束。

### 1.2.1 Properties of Mutual Exclusion

为了表明标志协议是解决爱丽丝和鲍勃问题的正确方法，我们必须了解解决方案需要哪些属性，然后证明协议满足它们。

首先，我们证明了宠物被排除在院子里的同时，我们称之为互斥的属性。

相互排斥只是感兴趣的几个属性之一。 毕竟，正如我们前面提到的，爱丽丝和鲍勃永远不会释放宠物的协议满足互斥属性，但不太可能满足他们的宠物。 这是另一个至关重要的属性。 首先，如果一只宠物想要进入院子，那么它最终会成功。 其次，如果两只宠物都想要进入院子，那么最终其中至少只有一只能成功。 我们认为这种死锁自由属性(deadlock-freedom property)是必要。

我们声称爱丽丝和鲍勃的协议没有死锁(deadlock-free)。 假设两只宠物都想使用院子。 爱丽丝和鲍勃各自升起了旗帜。 鲍勃最终注意到爱丽丝的旗帜升起，又慢慢降下了旗帜，从而没有让她的猫进入院子。


引人注目的另一个特性是饥饿自由 starvation-freedom（有时称为锁定自由 lockout-freedom）：如果宠物想要进入院子，它最终会成功吗？ 在这里，爱丽丝 和 鲍勃 的协议表现不佳。 每当爱丽丝和鲍勃发生冲突时，鲍勃都会向爱丽丝妥协，因此爱丽丝的猫可能一遍又一遍地使用院子，而鲍勃的狗变得越来越不爽。 稍后，我们将看到如何使协议防止饥饿。

感兴趣的最后一个属性是等待。 想象一下，爱丽丝举起她的旗帜，然后突然患上了阑尾炎。 她（和猫）被送往医院，手术成功后，接下来的一周她將在医院接受观察。 虽然鲍勃很放心，爱丽丝很好，他的狗直到爱丽丝回来，才能使用院子一整个星期。 问题是协议规定鲍勃（和他的狗）必须等待爱丽丝降低她的旗帜。 如果爱丽丝被延迟（即使有充分理由），那么鲍勃也会被推迟（没有明显的理由）。

作为容错(fault-tolerance)的一个例子，等待的问题很重要。 通常情况下，我们希望爱丽丝和鲍勃在合理的时间内相互回应，但如果他们不这样做会怎么样？ 从本质上讲，互斥问题需要等待：无论互相排斥协议多么聪明，都不会避免它。 然而，我们看到许多其他协调问题可以在不等待的情况下解决，有时候是以意想不到的方式。

### 1.2.2 The Moral

在回顾了Bob和Alice的协议的优点和缺点之后，我们现在将注意力转回到计算机科学。

首先，我们检查为什么在整个院子里喊叫并拨打手机电话无法正常工作。 并发系统中自然会发生两种通信：

- 即时通信(Transient communication)要求双方同时参与。 喊叫，打手势或手机通话是即时通信的例子。
- 持久通信(Persistent communication)允许发送者和接收者在不同时间参与。 在岩石上坐标记，发送电子邮件或留言都是持久沟通的例子

相互排斥需要持久化通信(Persistent communication)。 穿过院子或拨打手机电话的问题是，如果爱丽丝无法回复消息，鲍勃将永远不会知道, 他该不该把狗放进院子里去耍。

罐子和绳子协议(can-and-string)协议需要人参与其中，但它与并发系统中的通用通信协议准确对应：中断(interrupts)。 在现代操作系统中，一个线程引起另一个线程注意的一种常见方式是向其发送中断信号。 更准确地说，线程 A 通过在由 B 定期检查的标志置设置一个位来中断 B 线程。 B 迟早会注意到该位已被设置,并作出反应。 作为反应，B通常会复位该位（A不能复位该位）。 尽管中断无法解决互斥问题，但它们仍然非常有用。 例如，中断通信是 Java 语言的 wait() 和 notifyAll() 调用的基础。


## 1.3 The Producer-Consumer Problem

相互排斥不是唯一值得研究的问题。 最终，爱丽丝和鲍勃坠入爱河并结婚。 最终，他们离婚了。 （他们在想什么？）法官给爱丽丝保管宠物，并告诉鲍勃喂他们。 宠物现在彼此相处融洽，但他们与爱丽丝站在一起，并在看到鲍勃时攻击他。 因此，爱丽丝和鲍勃需要为鲍勃设计一个协议，在鲍勃和宠物没有同时在院子里的情况下向宠物提供食物。此外，协议不应该浪费任何人的时间：爱丽丝不想释放她的宠物到院子,除非那里有食物，鲍勃不想进入院子，除非宠物食用了所有的食物。 这个问题被称为生产者-消费者问题(Producer-Consumer Problem)。

令人惊讶的是，我们拒绝互相排斥的罐头和绳子协议(can-and-string protocol)正是我们对生产者 - 消费者问题所需要的。 鲍勃把一个罐子放在爱丽丝的窗台上，把绳子的一端系在罐头上，把绳子的另一端放在他的起居室里。 然后他把食物放在院子里，然后将罐子敲下来。 从现在开始，当爱丽丝想要释放宠物时，她会做以下事情：

1. 她一直等到罐子掉下来。
2. 她把猫和狗放到院子里。
3. 当宠物们从院子里回来的时候，爱丽丝检查食物吃完了没有，如果吃完了，她就吧罐子立起来。

鲍勃需要这样做：

1. 他会一直等，知道罐子被立了起来。
2. 他把食物放到院子里面去。
3. 他拉一下绳子，把罐头拉倒。

罐子的状态可以影响到院子的状态。 如果罐子掉下来，就意味着宠物可以去院子里吃食物，如果罐头立了起来，这意味着食物吃完了，鲍勃可以去放一些。 我们检查以下三个属性：

- 互斥条件(Mutual Exclusion): 鲍勃和宠物永远不会同时到院子里面去。
- 饥饿自由(Starvation-freedom)：如果鲍勃总是愿意喂养，并且宠物总是饥肠辘辘，那么宠物将无限次地进食。
- 生产者-消费者(Producer-Consumer): 只有在院子里有食物的情况下，宠物才能到院子里去。如果院子里的食物没有被吃完，鲍勃是不会往院子里放食物的。

这个生产者-消费者协议(Producer-Consumer protocol)和上一节中考虑的互斥协议(Mutual-Exclusion protocol)都确保爱丽丝和鲍勃不会同时在院子里。 然而，爱丽丝和鲍勃不能使用这种生产者-消费者协议进行互斥，理解其中的原因很重要。 互斥协议需要死锁自由(deadlock-freedom)：任何人都必须能够自己无限地进入院子，即使对方不在那里。 相比之下，生产者-消费者协议的饥饿自由财产(Starvation-Freedom property)承担了双方的持续合作。

以下是我们使用这个协议的理由：

- 互斥条件: 和先前使用的互斥条件证明相比，我们使用了略有不同的证明样式：状态机("state machine") — 基于证据，而不是矛盾。我们可以栓了绳子的罐子想像成一个状态机。罐子有两个状态，立起和倒下, 它在这些状态之间反复转换。我们认为互斥是最初的，并且在从罐头的任何状态转换到另一个状态时继续存在。

罐头的初始状态可以立起或者倒下。 让我们假设它是倒下的。 然后宠物可以进入院子，互斥条件得以满足。 为了让爱丽丝能够立起罐子，宠物必须先离开，所以当罐子被立起时，宠物不在院子里并保持相互排斥，因为它们不会再被进入，直到它被撞倒。 为了能够翻倒罐头，鲍勃必须离开院子，直到罐子再次被立起时才会进入，所以一旦罐子翻倒就会保持相互排斥。 没有其他可能的过渡，因此我们的主张成立。

- 饥饿自由(Starvation-freedom)：　假设声明不成立：情况必然是长期处于:爱丽丝的宠物挨饿，因为院子里没有食物，鲍勃试图提供食物但却没有成功。 罐子不能是立起来，因为鲍勃将提供食物并拉到罐头，让宠物吃。 所以它必须是罐子掉下来，而且由于宠物很饿，爱丽丝最终会把罐头立来，把我们带回原来的情况。

- 生产者消费者(Producer-Consumer) ：　互斥属性意味着宠物和宝贝永远不会在院子里。 在爱丽丝立起罐头之前，鲍勃不会进入院子，只有在没有食物的情况下她才会这样做。 同样地，宠物不会进入院子，直到鲍勃拉到罐子，他只有在放置食物后才会这样做。

与我们已经描述的互斥协议(mutual exclusion protocol)一样，该协议也会出现等待。 如果鲍勃在院子里存放食物，并立即去度假而不记得重置罐头，那么尽管存在食物，宠物可能会饿死。

将注意力转回计算机科学，生产者-消费者问题(Producer-Consumer problem)几乎出现在所有并行(parallel)和分布式系统(distributed systems)中。 这是处理器将数据放置在通信缓冲区中以通过网络互连或共享总线的方式读取或传输。


## 1.4 The Readers-Writers Problem

鲍勃和爱丽丝最终决定他们非常爱他们的宠物，他们需要传达关于他们的简单信息。 鲍勃在他家门口放了一个广告牌。 广告牌上有一系列大型的磁性卡片，每个卡片上都有一个字母。 鲍勃，闲暇时，一次举起一个卡片，在公告板上张贴一条消息。 爱丽丝闲暇时，通过望远镜观看广告牌，一次一张。

这可能听起来像一个可行的系统，但事实并非如此。 想象一下Bob发布消息：
```shell
sell the cat
```

爱丽丝，用她的望远镜看了一下，抄写了一下消息:
```shell
sell the
```

在爱丽丝抄消息的时候，鲍勃把所有的卡片都取了下来，然后写上了一条新的消息:
```shell
wash the dog
```

而爱丽丝，则继续用望远镜在广告牌上往后看，并翻译消息:
```
sell the dog
```

你可以想像一下结果:

有一些直接的方法来解决读者-作家的问题。

- 爱丽丝和鲍勃可以使用互斥协议(mutual exclusion protocol)以确保爱丽丝看到的只能是完整的语句。然而，爱丽丝仍然会错过一条语句。
- 他们可以使用罐子和绳子协议(can-and-string protocol), 鲍勃写好语句后，爱丽丝读取这些语句。

如果这个问题那么容易得到解决的话，那我们还有必要在这里提出这个问题呢？互斥协议(mutual exclusion protocol) 和　生产者消费者协议(producer-consumer protocol) 都需要等待: 如果一个参与者遭遇意外延迟，另一个参与者也会受到意外延迟。读者 - 作家问题的解决方案是一种允许的方式捕获几个内存位置的瞬时视图的线程。无需等待即可捕获此类视图，即在不阻止其他线程在读取这些位置时修改这些位置，这是一种功能强大的工具，可用于备份，调试以及许多其他情况。令人惊讶的是，读者编写者的问题确实存在不需要等待的解决方案。 我们稍后会研究几种这样的解决方案。

## 1.5 并行化的严酷现实

这就是多处理器编程非常有趣的原因。 在理想的世界中，从单处理器升级到n路多处理器应该可以提供大约n倍的计算能力。 实际上，遗憾的是，这种情况从未发生过。 其主要原因是，在不产生处理器间通信和协调的成本的情况下，大多数现实世界的计算问题无法有效并行化。 

考虑五个朋友决定粉刷一个拥有五个房间的房子。 如果所有的房间都是相同的大小，那么指派每个朋友粉刷一个房间是有意义的，只要每个人以大约相同的速度进行粉刷，我们就可以比一个人粉刷的情况加快五倍的速度。 如果房间大小不同，任务就会变得更加复杂。 例如，如果一个房间的大小是其他房间的两倍，那么五个人将不会达到五倍的加速，因为总体完成时间由占用时间最长的一个房间占主导地位。

这种分析对于并发计算非常重要。 我们需要的公式叫做Amdahl定律(Amdahl's Law)。 它抓住了这样一种观念，即我们可以加速任何复杂工作（不仅仅是粉刷房间）的程度必须受到按顺序执行多少工作的限制。

将作业的加速比S定义为一个处理器完成作业所需的时间（由挂钟测量）与并发处理器完成相同作业所需的时间之间的比率。Amdahl定律描述了n个处理器在应用程序上协作可以实现的最大加速比S，其中p是可以并行执行的作业的一部分。为简单起见，假设单个处理器完成作业需要（标准化）时间1。 对于n个并发处理器，并行部分需要时间p / n，而顺序部分需要时间1-p。 总的来说，并行计算需要时间：


![Formula 1-1 ](https://github.com/mysonhushu/the-art-of-multiprocessor-programming-zh/blob/master/manuscript/images/formula1-1.png "formula 1.1")

Amdahl定律(Amdahl's Law)说，加速率，即顺序（单处理器）时间和并行时间之间的比率是：


![Formula 1-2 ](https://github.com/mysonhushu/the-art-of-multiprocessor-programming-zh/blob/master/manuscript/images/formula1-2.png "formula 1.2")

为了说明阿姆达尔定律的含义，请考虑我们的房间粉刷示例。 假设每个小房间是一个单元，单个大房间是两个单元。 为每个房间分配一个粉刷匠（处理器）意味着六个单元中的五个可以平行绘制，这意味着p = 5/6，并且1-p = 1/6。 阿姆达尔定律指出，最终的加速度是：


![Formula 1-3 ](https://github.com/mysonhushu/the-art-of-multiprocessor-programming-zh/blob/master/manuscript/images/formula1-3.png "formula 1.3")

令人震惊的是，五个画家在五个房间工作，其中一个房间是其他房间的两倍，加速度只增加了三倍。

它会变得更糟。 想象一下，我们有十个房间和十个画家，每个画家被分配到一个房间，但一个房间（十个）是其他房间的两倍。 这是最终的加速：

![Formula 1-4 ](https://github.com/mysonhushu/the-art-of-multiprocessor-programming-zh/blob/master/manuscript/images/formula1-4.png "formula 1.4")

即使是一个小小的不平衡，将十个粉刷匠应用于工作也只能产生五倍多一点的加速，大约是人们可能期望的一半。

因此，与我们早期的基本粉刷问题一样，解决方案似乎是，一旦一个粉刷匠在一个房间的工作完成了，他/她就帮助其他人粉刷剩余的房间。 问题当然是共同粉刷这个房间需要粉刷匠之间的协调，但我们可以想办法避免吗？

以下是Amdahl定律告诉我们多处理器机器的使用情况。一些计算问题是“令人尴尬的并行”：它们可以很容易地分成可以同时执行的组件。这些问题有时会出现在科学计算或图形中，但很少出现在系统中。然而，总的来说，对于给定的问题和十处理器的机器，Amdahl定律说，即使我们设法并行化90％的解决方案，而不是剩下的10％，那么我们最终加速了五倍，但不是十倍的加速。换句话说，我们没有并行化的剩余10％将我们对机器的利用率降低了一半。似乎值得投入努力从尽可能多的剩余10％中获得尽可能多的并行性，即使它很难。通常，这很难，因为这些额外的并行部分涉及实质性的沟通和协调。以下是本书的主要重点：了解允许程序员有效编写需要协调和同步的代码部分的工具和技术，因为这些部分的优势可能会对性能产生深远的影响。

回到图1.2的素数打印程序，让我们重新审视三个主要代码行：
```java
i = counter.getAndIncrement();  // take next untaken number
if (isPrime(i)) {
    print(i);
}

```

让线程以原子方式执行这三行，即在一个互斥的块中，会更简单。 相反，只有对 getAndIncrement() 的调用才是原子的。 当我们考虑Amdahl定律的含义时，这种方法是有意义的：最小化顺序代码的粒度很重要; 在这种情况下，使用互斥访问的代码。 此外，重要的是以有效的方式实现互斥，因为围绕互斥的共享计数器(shared counter)的沟通和协调可以对整个计划的绩效产生重大影响。

## 1.6 Parallel Programming

对于您希望并行化的许多应用程序，您可能会发现有很多重要部分可以轻松地确定为可执行并行执行的，因为它们不需要任何形式的协调或通信。 但是，在撰写本书时，没有用于识别这些部分的通用方法。 这是应用程序设计人员需要使用他或她对并行算法的累积理解的地方。 幸运的是，在很多情况下,可以很轻易地找到这样的部分。 本书所涉及的问题是如何处理程序的其余部分。 如前所述，这部分是无法轻松并行化的部分，因为程序必须访问共享数据，并且需要以基本方式进行进程间协调和通信。

本文的目的是向读者展示现代协调范式和并发数据结构背后的核心思想。 我们向读者展示了有效多处理器编程关键元素的统一，全面的图像，从基本原理到最佳实践工程技术。

多处理器编程带来了许多挑战，从宏大的知识问题到微妙的工程技巧。 我们使用连续改进来应对这些挑战，首先是理想化的模型，其中数学关注是最重要的，并逐渐转向更实用的模型，我们越来越关注基本的工程原理。

例如，我们考虑的第一个问题是互斥，这是该领域中最古老的，也是最基本的问题之一。 我们从数学角度开始，分析理想化架构上各种算法的可计算性和正确性。 算法本身虽然经典，但对于现代架构来说并不实用。 然而，学习如何推理这种理想化算法是学习如何推理更现实（和更复杂）算法的必要步骤。 学习如何推理诸如饥饿(starvation)和死锁(deadlock)等微妙的活跃问题尤为重要。

一旦我们理解了如何推理这些算法，我们就会将注意力转向更现实的背景。 我们使用不同的多处理器体系结构探索各种算法和数据结构，目的是了解哪些是有效的，以及为什么。

## 1.7 Chapter Notes

Alice和Bob的大部分寓言改编自Leslie Lamport的邀请地址，参加1984年ACM分布式计算原理研讨会[https://www.podc.org/]。 读者-作家问题是一个经典的同步问题，在过去的二十年中已经在许多论文中受到关注。 Amdahl定律归功于Gene Amdahl，一位并行处理先驱[https://en.wikipedia.org/wiki/Amdahl%27s_law]。

## 1.8 Exercises

**Exercise 1.** 哲学家就餐的问题是由并发先驱E. W. Dijkstra发明的，旨在澄清死锁(dead-lock)和饥饿自由(starvation freedom)的概念。 想象一下五个哲学家，他们终其一生只是在思考和就餐。 他们坐在一张带五把椅子的圆桌旁。 每个位置前面有一大盘米饭。 但是，只有五根筷子（在原文中说的是刀叉）可用，如图1.5所示。 每个哲学家都在思考。 当他饿了，他坐下来拿起最接近他的两根筷子。 如果一个哲学家可以拿起两根筷子，他可以吃一段时间。 在一位哲学家吃完之后，他放下筷子再次开始思考。

1. 编写一个程序来模拟哲学家的行为，每个哲学家都是一个线程，筷子是共享对象。 请注意，您必须防止两位哲学家同时持有相同筷子的情况。
2. 修改你的程序，使其永远不会达到哲学家陷入僵局的状态(deadlocked status)，也就是说，每个哲学家都持有一根筷子并且等待拿到第二根筷子的情况永远不会发生。
3. 修改你的程序，以免任何哲学家挨饿。
4. 编写一个程序，为任何数量的哲学家提供饥饿自由(starvation-free)的解决方案。


![Figure 1.5 Traditional dining table arrangement according to Dijkstra](https://github.com/mysonhushu/the-art-of-multiprocessor-programming-zh/blob/master/manuscript/images/Figure1-5.png "Figure 1.5 Traditional dining table arrangement according to Dijkstra.")

>备注: 自己写了一个答案,不是标准答案，参卡: [哲学家就餐问题](https://github.com/mysonhushu/philosopher-eat)


**Exercise 2.** 对于以下各项，请说明它是安全性还是活跃性。找出感兴趣的坏事或好事。

1. 顾客按照他们到达的顺序送达。
2. 有升必有降。
3. 如果两个或多个进程正在等待进入其关键部分，至少有一个成功。
4. 如果发生中断，则在一秒钟内打印一条消息。
5. 如果发生中断，则打印一条消息。
6. 生活成本永远不会降低。
7. 有两件事是肯定的：死亡和税收。
8. 你总能告诉一个哈佛男人。


**Exercise 3.** 在生产者 - 消费者的寓言中，我们假设Bob可以看到Alice的窗台上的罐子是上升还是下降。使用罐子和绳子设计 生产者-消费者 协议，即使Bob无法看到Alice的状态（这是现实中断位的工作方式）也能正常工作。

**Exercise 4.** 你是最近被捕的囚犯之一,你的名字叫:P。监狱长是一位丧心病狂的计算机科学家，他发表以下声明：

>你们今天可以会聚在一起并计划一个策略，但是在今天之后，你们将被单独地关在监狱中,并且彼此之间不能再进行任何交流了。
>
>我已经布置了一个“开关室”，其中包含一个开关，可以打开或关闭。开关没有连接任何灯泡之类的东西。
>
>我会不时地随机选择一名囚犯进入“开关室”。这名囚犯可能会拨动开关（从开启到关闭，反之亦然），或者可以保持开关不变。此时没有人会进入这个房间。
>
>每个囚犯将经常任意进入这个房间。更准确地说，对于任何N个囚犯，最终你们每个人都会至少N次进入这个房间。
>
>在任何时候，你们中的任何人都可以告诉我：“我们所有人都至少有一次进过这个房间了。”如果说对了，我会放了你们。如果说错了，我会把你们所有人都送去喂鳄鱼。接下来就看你们的了！



- 当您知道开关的初始状态关闭时，设计一个获胜策略。
- 当您不知道开关的初始状态是打开还是关闭时，设计一个获胜策略。

提示：并非所有囚犯都需要做同样的事情。

**Exercise 5.**
同一个监狱长有不同的想法。 他命令囚犯排队站成一列，并在他们的每个头上放置红色或者蓝色的帽子。没有囚犯知道他自己的帽子的颜色，或他身后任何囚犯帽子的颜色，但他可以看到前面的所有囚犯的帽子颜色。监狱长从队列的后面开始，要求每个囚犯猜测自己帽子的颜色。 囚犯只能回答“红色”或“蓝色”。如果他给出了错误的答案，他就会被拉到要喂鳄鱼那边。 如果他回答正确，他就会被释放。 每个囚犯都可以听到身后囚犯的回答，但无法判断囚犯是否正确。

允许囚犯在戴帽子之咨询并商定策略（在监狱长听的时候），但在排队之后，除了回答“红色”或“蓝色”之外，他们不能以任何其他方式进行交流。

制定一项策略，允许P个囚犯中至少P-1个囚犯获释。

>我没有找到答案，但是我觉得可以用声音的长短传达额外的信息。


**Exercise 6.**
使用 Amdahl's Law 来解决下面这些问题:

- 假设一个计算机程序有一个无法并行化的方法M，并且该方法占该程序执行时间的40％。 在n处理器多处理器计算机上运行程序可以实现整体加速的限制是多少？
- 假设方法M占程序计算时间的30％.M的加速应该是什么，以便总体执行时间提高2倍？
- 假设方法M可以加速三倍。 为了使程序的整体加速比增加一倍，M必须占总执行时间的一小部分？

**Exercise 7.**
在两个处理器上运行应用程序会产生 S2 的加速。 使用Amdahl定律推导出S n的公式，n个处理器的加速，以 n 和 S2 表示。

**Exercise 8.**
您可以选择购买一个每秒执行五亿条指令的单处理器，也可以选择十个处理器多处理器，每个处理器每秒执行五千万条指令。 使用Amdahl定律，解释如何决定为特定应用购买哪种产品。
















































