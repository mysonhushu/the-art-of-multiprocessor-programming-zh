# 1.Introduction

因为多核架构的创新设计，计算机行业正在经历一场翻天覆地的变化。 至少目前，主要的芯片制造商已放弃尝试使处理器运行得更快。 摩尔定律尚未废除：每年，越来越多的晶体管适用于相同的空间，但是如果没有过热，它们的时钟速度就无法提高。 相反，制造商正在转向“多核”架构，其中多个处理器（核心）通过共享硬件缓存直接通信。多处理器芯片通过利用并行性使计算更有效：利用多个处理器来处理单个任务。

多处理器架构的普及将对我们开发软件的方式产生普遍影响。 直到最近，技术的进步意味着时钟速度的提高，因此软件会随着时间的推移自动“加速”。 然而，现在这个免费搭车已经结束了。 技术的进步将意味着增加并行性而不是提高时钟速度，并且利用这种并行性是现代计算机科学的突出挑战之一。

本书重点介绍如何基于共享内存进行通信的多处理器进行编程。 此类系统通常称为共享内存多处理器，最近又简称为多核(multicores)。 编程挑战出现在多处理器系统的各种规模上 - 在非常小的规模上，单个芯片内的处理器需要协调对共享存储器位置的访问，而在大规模上，超级计算机中的处理器需要协调数据的路由。 多处理器编程具有挑战性，因为现代计算机系统本质上是异步的：可以在没有中断，抢占，高速缓存未命中，故障和其他事件警告的情况下停止或延迟活动。 这些延迟本质上是不可预测的，并且可能在规模上有很大差异：高速缓存未命中可能使处理器延迟少于10个指令，几百万个指令的页面错误，或者数亿个指令的操作系统抢占。

我们从两个互补的方向探讨多处理器编程：原理和实践。 在本书的原理部分，我们关注可计算性：确定可以在异步并发环境中计算的内容。 我们使用理想化的计算模型，其中多个并发线程操纵一组共享对象。 对象上的线程操作序列称为并发程序(concurrent program)或并发(concurrent algorithm)算法。 该模型本质上是Java，C＃或C ++线程包提供的模型。

令人惊讶的是，有一些易于指定的共享对象无法通过任何并发算法实现。 因此，在继续编写多处理器程序之前，了解不要尝试的内容非常重要。 使多处理器程序员陷入困境的许多问题都是计算模型基本限制的结果，因此我们认为获得对并发共享内存可计算性的基本理解是必要的步骤。 处理原则的章节让读者快速浏览异步可计算性，尝试揭示各种可计算性问题，以及如何通过使用硬件和软件机制解决这些问题。

理解可计算性的一个重要步骤是规范和验证给定程序实际执行的操作。这可能最好描述为程序正确性。多处理器程序本身的正确性比它们的顺序对应程序更复杂，并且需要一套不同的工具，即使是为了“非正式推理”（当然，这是大多数程序员实际做的事情） ）。顺序正确性主要与安全性有关。安全性表明某些“坏事”永远不会发生。例如，即使电源出现故障，红绿灯也不会在所有方向上显示绿色。当然，并发正确性也与安全性有关，但问题要困难得多，因为尽管可以交错并发线程的步骤的方式很多，但必须确保安全性。同样重要的是，并发正确性包含在顺序世界中没有对应物的各种活跃属性。活跃的安全性声明会发生一件特别好的事情。例如，红色交通灯最终会变为绿色。本书涉及原则的部分的最终目标是引入各种计量和方法来推理并发程序，这些程序稍后将在讨论现实世界对象和程序的正确性时为我们服务。

本书的第二部分涉及多处理器编程的实践，并侧重于性能。 分析多处理器算法的性能与分析顺序程序的性能方面也有所不同。 顺序编程基于一系列成熟且易于理解的抽象。 当我们编写顺序程序时，我们通常不需要知道在它下面的所有页面都是从磁盘交换到内存，而较小的内存单元正在进出处理器缓存的层次结构。 这种复杂的内存层次结构基本上是不可见的，隐藏在简单的编程抽象背后。

在多处理器上下文中，这种抽象分解，至少从性能角度来看。 为了获得足够的性能，程序员有时必须“知晓”底层内存系统，编写对于不熟悉多处理器体系结构的人来说看起来很奇怪的程序。有时候，并发体系结构将提供现在由顺序体系结构提供的相同程度的高效抽象，但是 与此同时，程序员应该小心。

本书的原理部分陆续介绍了共享对象和编程工具的集合。 每个对象和工具本身都很有趣，我们通过各个对象和工具向读者展示更高级别的问题：自旋锁说明了争用，链表说明了锁定在数据结构设计中的作用，等等。 这些问题中的每一个都对程序性能产生重要影响。 希望读者将所学到的知识应用于特定多处理器系统的编程实践中。 我们最后将讨论最先进的技术（如事务存储器）。

我们想简单介绍一下风格。 本书使用Java编程语言。 当然，还有其他合适的语言，读者会发现它们同样具有吸引力。 我们有一长串原因供我们选择，但也许更适合在茶话会上讨论选择哪种语言！ 在附录中，我们解释了如何用其他流行语言或库表达Java中表达的概念。 我们还提供了多处理器硬件的入门知识。 在整本书中，我们避免为程序和算法提供特定的性能参数，并坚持一般趋势。 这有一个很好的理由：多处理器差别很大，不幸的是，在这个时间点，在一台机器上运行良好的程序在另一台机器上可能会显着不那么令人满意。 坚持一般趋势是我们保证我们的结果在长时间内正确的一种方式。

我们提供每章末尾的参考资料。 读者将找到所涵盖材料的书目调查，并提供进一步阅读的建议。 每一章还包括一系列练习，读者可以用这些练习来衡量他们在星期天早上的理解或自我检测。

## 1.1 Shared Objects and Synchronization

在你的新工作的第一天，你的老板要求你找到1到10的10次方(\$ x^2 \$)之间的所有素数（不要关心为什么），使用支持10个并发线程的并行机器。 这台机器按分钟租用，因此程序花费的时间越长，成本就越高。 你想给人留下好印象。 你该怎么办？

作为第一次尝试，您可以考虑为每个线程分配相同的输入域份额。 每个线程可能会检查10的9次方个数字，如图1.1所示。 出于基本但重要的原因，这种方法失败了。 相同范围的投入不一定产生相同数量的工作。 素数不均匀地发生：1到109之间有许多素数，但在9乘以10的9次方到10的10次方之间几乎没有。更糟糕的是，每个素数的计算时间在所有范围内都不相同：通常需要更长的时间来测试是否大数是素数而不是小数。 简而言之，没有理由相信工作将在线程之间平均分配，并且即使哪些线程最有效也不清楚。

```java
Counter counter = new Counter(1); // shared by all threads
void primePrint {
    long i = 0;
    long limit = power(10, 10);
    while (i < limit) {           // loop until all numbers taken
        i = counter.getAndIncrement();  // take next untaken number
        if (isPrime(i))
             print(i);

    }
}
```

[Figure 1.1 Balancing load by dividing up the input domain. Each thread in {0..9} gets an equal subset of the range. ](https://github.com/mysonhushu/the-art-of-multiprocessor-programming-zh/blob/master/manuscript/images/Figure1-1.png)





















